메모리를 분류하는여러가지관점 *** 조사해서 공부
1.
on chip 레지스터 -> 프로그램카운터 스택포인터 r0 rn까지의 버퍼, RAM(데이터, 변수의 값을 담는)
레지스터는 잠깐 기억해서 빠르게 계산하는것
2
휘발성(ram)-플립플롭 보다 더 빠른건 캐시 (보통 플립플롭으로 이루어짐) s ram(플립플롭 4개) d ram (플립플롭 1개)

3
비휘발성(rom)- 물리적으로 스트레스를 가해서 전기적으로 남게해야함 예쩐에 cd롬으로 열을 가해서 파버림
그다음에 자기장으로 자기극성을 바꿔서 0과 1 새기고 지금나오는거는 플래시메모리 라고해서 
트랜지스터에 수십볼트의 부하를가해서 비트하나하나에 할수없어서 1 단위당 ex) 수십k단위로  다지우고
번쩍 지우고 다시 메모리에 있던 바꾼데이터와 기존데이터를 rewrite함 알고리즘을 이용하여 효율 올림


리눅스 move명령어

mv 위치 /* .

버츄어박스 의미 binary translation

arm 


binary의 실행 포멧 ) 윈도우.exe  리눅스.elf 구조가 달라서 헤더도 다르고 
os따라서도 안되고 cpu따라서도 다름


버츄어박스는 binary translation을 함
ex) 내 노트북은 윈도우 64비트에 amd코어인데

버츄어박스에서는 리눅스 64비트 운영체제여서 변환해야함 즉, amd는 같은데 os가 다름

 다른 os와 다른 cpu 타겟 qemu도 버츄어박스랑 같은원리 (cpu가 다르게 실행) 
실행파일은 arm isa로 채워짐

os 는계산속도가 빠르나 무겁고 배터리 소모 많고 critical한 군사용 장비 등에서는 거의쓰면안됨


비트 마스킹 비스 클리어

지울때는 AND로 지움 0과 AND를 하면 무조건 지워짐

예를들어 0x95에서 10010101 에서 10000101로 5번째를 마스킹하고싶다 
그러면 11101111을 and 해도되고
00010000 = 0x10 을 ~ 줘서 and해도 똑같음 (좀더 직관적)

elf에서 bin으로 하는것은 칩위에 올리기위해 binary만 뽑아내서 가볍게 만드는것


si 스택은 진행 사항 대로 (pc위치따라)
n  은 c코드상에서 바로 실행( 함수부분처럼 몇개는 점프해버림)
db memory watch로 확인 가능

arm 에서 thumb모드가 있는데 저전력 고효율 방식임 16비트
그래서 pc카운터가 2씩증가함

make gdb

target remote:1234 

gdb) file out.elf

gdb) load

gdb) b(reakpoint) main

n을 치면 넘어가면서 걸리느느부분 확인
q누르면 종료